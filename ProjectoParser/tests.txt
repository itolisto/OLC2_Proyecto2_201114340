


struct Mascota {
string[][][] nombre;
}
struct Persona {
string nombre;
//int alto;
Mascota[][] edad;
}


Persona x = Persona{ 
  nombre:"yo",
  edad: {
    {     
      Mascota{ 
        nombre:new string[2][2][1] 
      },
      Mascota{ 
        nombre:{{{"e"},{"f"}},{{"g"},{"h"}}} 
      }
    },
    {
      Mascota{ 
        nombre:{{{"i"},{"j"}},{{"i"},{"l"}}} 
      },
      Mascota{ 
        nombre:{{{"m"},{"n"}},{{"o"},{"p"}}} 
      }
    }
  }
};

------------------------------
struct Mascota {
string[][][] nombre;
}
struct Persona {
string nombre;
//int alto;
Mascota[][] edad;
}


Persona x = Persona{ 
  nombre:"yo",
  edad: {
    {     
      Mascota{ 
        nombre:{{{"a"},{"b"}},{{"c"},{"d"}}} 
      },
      Mascota{ 
        nombre:{{{"e"},{"f"}},{{"e"},{"g"}}} 
      }
    },
    {
      Mascota{ 
        nombre:{{{"h"},{"i"}},{{"j"},{"l"}}} 
      },
      Mascota{ 
        nombre:{{{"m"},{"n"}},{{"o"},{"p"}}} 
      }
    }
  }
};

//x.edad.nombre[1];

//Mascota z = Mascota{ nombre:{{{"a"},{"b"}},{{"c"},{"d"}}} };
x.edad[1][1].nombre[0][0][0];

-------------------
struct Mascota {
string[] nombre;
}
struct Persona {
string nombre;
int alto;
Mascota edad;
}

Mascota{ nombre:"sisisis" };

// struct Mascota {
// string nombre;
// }
// struct Persona {
// string nombre;
// int edad;
// Mascota edad;
// }

// Mascota s;
// int y = 1;
// int[][] x = {{y,y},{1,2}};
// Mascota[][] z = {{null},{null}};

// x[1];
// z;
// s;

String mkl(
Int a
, String a
) {
var a = new Int[3][4];
Int[][] b = new Int[3][4];
var c = {new Int[3][4],2,3};
Int[] d = typeof {new Int[3][4],2,3};

String[] a = x[2][3];
break;
continue;
{ continue;}
{ break;}
return false;
var d = d;

while (true) {
String[] a = x[2][3];
break;
{ return;}
{ break;}
return;
var d = true;
}
} 


String mkl(
Int a
, String a
) {

String[] a = x[2][3];
break;
continue;
{ continue;}
{ break;}
return false;
var d = d;

switch(a) {
case true:
String a = 'a';
break;
case "":
String a;
break;
{ continue;}
{ break;}
default:
String[] a = x[2][3];
break;
{ return 1;}
{ break;}
return;
}
} 

// while (true) {
// String[] a = x[2][3];
// break;
// { continue;}
// { break;}
// return;
// var d = true;
// }

// if(true) {
// String[] a = x[2][3];
// break;
// { continue;}
// { break;}
// return;
// var d;
// }


// switch(a) {
// case true:
// String a = 'a';
// break;
// case "":
// String a;
// break;
// { continue;}
// { break;}
// default:
// String[] a = x[2][3];
// break;
// { continue;}
// { break;}
// return;
// }





//for(String a = b = v; ;) {
//c = 1>=4;
//break;
//}

//var x = m;












//{ type{ type, arrayLevel }, name, value(expression) }
    visitVarDefinition(node) {
        // 1. check if something exists
        const definedNode = this.checkVariableExists(node.name)
        const location = node.location

        // 2. throw error if exists
        if(definedNode) throw new OakError(location, `variable ${node.name} already exists `) 

        // 2.b check if type exists
        const typeNode = node.type.interpret(this)
        const expected = typeNode.type
        const classDef = this.environment.get(expected)
        let defaultVal
        if(classDef instanceof OakClass) {
            defaultVal = new nodes.Literal({type: 'null', value: null})
        } else {
            defaultVal = this.nativeDefVal[expected]
            if(defaultVal != undefined ) {
                defaultVal = new nodes.Literal({type: expected, value: defaultVal})
            }
        }
    
        

        // 2.c if default value doesn't exists means type doesn't exists, if it exists and expression is null, assign it
        if(defaultVal == undefined) {
            throw new OakError(location, 'type doesnt exists ')
        } else if(!node.value) {
            // 2.d If value expression doesn't exist assign default check if type exists to assign value
            node.value = defaultVal
        }

        /** 
         * 3. this step may change but for now we are going to "spend" a computation
         * by interpreting the inner nodes, they are all interpreted everytime as for now,
         * all literals are saved as nodes, arrays, instances are saved as
         * a reference/instance, all of them has a type property
         */ 
        const value = node.value.interpret(this)
        // (hacky way to save some interpretations when it is accessed)
        node.value = value

        // 4. check if type are same and set
        
        const found = value.type
        if(expected == found || found == 'null') {
            // 5. check if type expected is an array, arrayLevel > 1 means is an array
            if(typeNode.arrayLevel > 0 && value instanceof OakArray) {
                if(value.deep == typeNode.arrayLevel) {
                    this.environment.set(node.name, node.value)
                    return
                }
                const expectedDeep = "[]".repeat(typeNode.arrayLevel)
                const foundDeep = "[]".repeat(value.deep)
                throw new OakError(location, `expected ${expectedDeep} but found ${foundDeep} `)
            }

            if(typeNode.arrayLevel>0 && classDef instanceof OakClass && found == 'null') throw new OakError(location, `expected ${expected}${"[]".repeat(typeNode.arrayLevel)} but found ${found} `)
            
            if(classDef instanceof OakClass) {
                this.environment.set(node.name, node.value)
                return
            }

            if(expected == found) {
                this.environment.set(node.name, node.value)
                return
            }
            
            throw new OakError(location, `expected ${expected} but found ${found} `)
        }

        // int fits into float edge case
        if(expected == 'float' && found == 'int') {
            // at this point node.value should be a literal
            node.value.type = 'float'
            node.value.value = parseFloat(`${node.value.value}.00`)
            this.environment.set(node.name, node.value)
            return
        }

        throw new OakError(location, `expected ${expected} but found ${found} `)
    }